<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Mars Viewer — A* Route Planner (Local Flask)</title>

  <!-- CesiumJS 1.123 -->
  <script src="https://cesium.com/downloads/cesiumjs/releases/1.123/Build/Cesium/Cesium.js"></script>
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.123/Build/Cesium/Widgets/widgets.css" rel="stylesheet"/>

  <style>
    html, body, #cesiumContainer { width:100%; height:100%; margin:0; padding:0; overflow:hidden; }
    #panel {
      position:absolute; top:12px; left:12px; z-index:1000;
      width:360px; padding:12px 14px;
      background:#121726; color:#e8ecff; border:2px solid #2a3357; border-radius:14px;
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      box-shadow:0 10px 30px rgba(0,0,0,.35);
    }
    #panel h1 { margin:0 0 8px 0; font-size:16px; }
    #panel .row { display:flex; gap:8px; align-items:center; margin:8px 0; flex-wrap:wrap; }
    #panel button {
      background:#7aa2ff; border:none; color:#0c0f17; font-weight:600;
      padding:8px 10px; border-radius:10px; cursor:pointer;
    }
    #panel button.secondary { background:#222a4a; color:#e6ecff; border:1px solid #2f396b; }
    #panel label { font-size:12px; color:#b9c0d9; }
    #panel input[type="range"] { width:150px; }
    #panel .pill { display:inline-block; padding:2px 8px; border-radius:999px; background:#1c2340; border:1px solid #2b3663; font-size:11px; color:#cdd7ff; }
    #panel #status { font-size:12px; color:#9fb2ff; min-height:1.4em; margin-top:6px; }
    #panel #list { max-height:130px; overflow:auto; border-top:1px dashed #2b3663; padding-top:6px; font-size:12px; }
    #legend {
      position:absolute; bottom:14px; left:12px; z-index:1000;
      background:#121726; color:#cdd7ff; border:1px solid #2b3663; padding:6px 8px; border-radius:10px; font-size:12px;
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
  </style>
</head>
<body>
  <div id="cesiumContainer"></div>

  <div id="panel">
    <h1>Mars Waypoints <span class="pill">A*</span></h1>

    <div class="row">
      <button id="toggleAdd">Adding… (click globe)</button>
      <button id="undo" class="secondary">Undo</button>
      <button id="clear" class="secondary">Clear</button>
    </div>

    <div class="row">
      <label>Grid (N × N)</label>
      <input id="grid" type="range" min="64" max="256" step="32" value="128">
      <span id="gridVal" class="pill">128</span>
    </div>
    <div class="row">
      <label>BBox margin (km)</label>
      <input id="margin" type="range" min="5" max="200" step="5" value="40">
      <span id="marginVal" class="pill">40</span>
    </div>
    <div class="row">
      <label>Max slope (grade)</label>
      <input id="maxSlope" type="range" min="0.05" max="1.5" step="0.05" value="0.60">
      <span id="maxSlopeVal" class="pill">0.60</span>
    </div>
    <div class="row">
      <label>Slope weight</label>
      <input id="slopeW" type="range" min="0" max="8" step="0.25" value="2.0">
      <span id="slopeWVal" class="pill">2.00</span>
    </div>

    <div class="row">
      <button id="solve">Solve Route (A*)</button>
      <button id="download" class="secondary">Download JSON</button>
    </div>

    <div id="status"></div>
    <div id="list"><em>No waypoints yet.</em></div>
  </div>

  <div id="legend">Toggle “Adding…”, then click the globe: Start → WP1 → … → End. Press “Solve Route (A*)”.</div>

  <!-- Your environment values (TITILER_URL / FLASK_URL / MARS_TIF, etc.) -->
  <script src="config.js"></script>

  <script>
    // ---------- ENV / URLs ----------
    const { TITILER_URL, FLASK_URL, MARS_TIF } = window.__ENV__ || {};
    const flaskBase = (FLASK_URL || "http://localhost:8081").replace(/\/$/, "");
    const titilerBase = (TITILER_URL || flaskBase).replace(/\/$/, "");
    const tifAbsolute = `${flaskBase}/${MARS_TIF || "mars_6p25_wgs84_cog.tif"}`;
    const tifParam = encodeURIComponent(tifAbsolute);

    // Cesium imagery via TiTiler (or compatible /cog/tiles server)
    const tileUrl = `${titilerBase}/cog/tiles/WorldCRS84Quad/{z}/{x}/{y}@1x?url=${tifParam}`;

    // Local A* API (server-side): POST /astar/solve
    async function solveRouteViaAPI(waypoints, gridN, marginKm, maxSlope, slopeW) {
      const payload = {
        positions: waypoints.map(p => ({ lon: p.lon, lat: p.lat })),
        grid: gridN,
        margin_km: marginKm,
        max_slope: maxSlope,
        slope_weight: slopeW
      };
      const resp = await fetch(`${flaskBase}/astar/solve`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });
      const js = await resp.json();
      if (!resp.ok || js.error) throw new Error(js.error || "A* failed");
      return js; // { positions: [{lon,lat},...], total_cost_m, legs_m }
    }

    // ---------- Cesium viewer ----------
    const viewer = new Cesium.Viewer("cesiumContainer", {
      imageryProvider: false,
      baseLayerPicker: false,
      geocoder: false,
      timeline: false,
      animation: false,
      sceneModePicker: true,
      selectionIndicator: false,
      scene3DOnly: true
    });

    // Mars ellipsoid
    viewer.scene.globe.ellipsoid = new Cesium.Ellipsoid(3396190.0, 3396190.0, 3376200.0);
    // Camera limits
    viewer.scene.screenSpaceCameraController.minimumZoomDistance = 4.0e5;
    viewer.scene.screenSpaceCameraController.maximumZoomDistance = 3.0e7;

    // Raster imagery from your COG tiles
    viewer.imageryLayers.addImageryProvider(new Cesium.UrlTemplateImageryProvider({
      url: tileUrl,
      tilingScheme: new Cesium.GeographicTilingScheme(),
      rectangle: Cesium.Rectangle.fromDegrees(-180, -90, 180, 90),
      credit: "Mars COG tiles"
    }));

    viewer.camera.flyTo({
      destination: Cesium.Cartesian3.fromDegrees(137.4, -4.6, 2_000_000),
      duration: 1
    });

    // ---------- UI elements ----------
    const $ = id => document.getElementById(id);
    const btnAdd = $("toggleAdd");
    const btnUndo = $("undo");
    const btnClear = $("clear");
    const btnSolve = $("solve");
    const btnDownload = $("download");
    const grid = $("grid"), gridVal = $("gridVal");
    const margin = $("margin"), marginVal = $("marginVal");
    const maxSlope = $("maxSlope"), maxSlopeVal = $("maxSlopeVal");
    const slopeW = $("slopeW"), slopeWVal = $("slopeWVal");
    const statusEl = $("status"), listEl = $("list");

    grid.oninput = () => gridVal.textContent = grid.value;
    margin.oninput = () => marginVal.textContent = margin.value;
    maxSlope.oninput = () => maxSlopeVal.textContent = (+maxSlope.value).toFixed(2);
    slopeW.oninput = () => slopeWVal.textContent = (+slopeW.value).toFixed(2);
    function status(msg){ statusEl.textContent = msg || ""; }

    // ---------- Waypoint logic ----------
    const waypoints = []; // {lon, lat, entity}
    let adding = true;
    let dashedEntity = null;
    let solvedEntity = null;

    btnAdd.onclick = () => {
      adding = !adding;
      btnAdd.textContent = adding ? "Adding… (click globe)" : "Add Waypoints";
      btnAdd.classList.toggle("secondary", !adding);
      status(adding ? "Click the globe to add waypoints." : "");
    };

    btnUndo.onclick = () => {
      const last = waypoints.pop();
      if (last?.entity) viewer.entities.remove(last.entity);
      redrawDashed(); renderList(); status("Undid last waypoint.");
    };

    btnClear.onclick = () => {
      waypoints.splice(0, waypoints.length);
      viewer.entities.remove(dashedEntity); dashedEntity = null;
      if (solvedEntity) { viewer.entities.remove(solvedEntity); solvedEntity = null; }
      viewer.entities.values
        .filter(e => e.__isWP)
        .forEach(e => viewer.entities.remove(e));
      renderList(); status("Cleared.");
    };

    btnDownload.onclick = () => {
      if (!waypoints.length) return;
      const data = { positions: waypoints.map(p => ({ lon: p.lon, lat: p.lat })) };
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = "route_lonlat.json";
      a.click();
      URL.revokeObjectURL(a.href);
    };

    function renderList(){
      if (!waypoints.length){ listEl.innerHTML = "<em>No waypoints yet.</em>"; return; }
      listEl.innerHTML = waypoints.map((p,i) => {
        const tag = i===0 ? "Start" : (i===waypoints.length-1 ? "End" : `WP${i}`);
        return `<div>${i+1}. <b>${tag}</b> — lon ${p.lon.toFixed(4)}, lat ${p.lat.toFixed(4)}</div>`;
      }).join("");
    }

    function redrawDashed(){
      if (dashedEntity){ viewer.entities.remove(dashedEntity); dashedEntity = null; }
      if (waypoints.length < 2) return;
      const degs = waypoints.flatMap(p => [p.lon, p.lat]);
      dashedEntity = viewer.entities.add({
        polyline: {
          positions: Cesium.Cartesian3.fromDegreesArray(degs),
          width: 2,
          material: new Cesium.PolylineDashMaterialProperty({ color: Cesium.Color.RED, dashLength: 12 }),
          clampToGround: false
        }
      });
      try {
        const rect = Cesium.Rectangle.fromDegrees(
          Math.min(...waypoints.map(p=>p.lon)), Math.min(...waypoints.map(p=>p.lat)),
          Math.max(...waypoints.map(p=>p.lon)), Math.max(...waypoints.map(p=>p.lat))
        );
        viewer.camera.flyTo({ destination: rect, duration: 0.6 });
      } catch(_) {}
    }

    function addWaypoint(lon, lat){
      const label = waypoints.length===0 ? "START" :
                    (waypoints.length===1 ? "END?" : `WP${waypoints.length}`);
      const entity = viewer.entities.add({
        __isWP: true,
        position: Cesium.Cartesian3.fromDegrees(lon, lat),
        point: { pixelSize: 8, color: Cesium.Color.CYAN, outlineColor: Cesium.Color.WHITE, outlineWidth: 1 },
        label: {
          text: `${label}\n${lon.toFixed(4)}, ${lat.toFixed(4)}`,
          font: "bold 14px sans-serif",
          showBackground: true,
          backgroundColor: Cesium.Color.fromBytes(18,23,38,220),
          pixelOffset: new Cesium.Cartesian2(0, -18),
          disableDepthTestDistance: Number.POSITIVE_INFINITY
        }
      });
      waypoints.push({ lon, lat, entity });
      renderList();
      redrawDashed();
    }

    const handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
    handler.setInputAction((movement) => {
      if (!adding) return;
      const ellipsoid = viewer.scene.globe.ellipsoid;
      const cart = viewer.camera.pickEllipsoid(movement.position, ellipsoid) || viewer.scene.pickPosition(movement.position);
      if (!cart) return;
      const carto = Cesium.Cartographic.fromCartesian(cart, ellipsoid);
      const lon = Cesium.Math.toDegrees(carto.longitude);
      const lat = Cesium.Math.toDegrees(carto.latitude);
      addWaypoint(lon, lat);
    }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

    function drawSolvedRoute(points){
      if (solvedEntity) { viewer.entities.remove(solvedEntity); solvedEntity = null; }
      const rad = points.flatMap(p => [Cesium.Math.toRadians(p.lon), Cesium.Math.toRadians(p.lat)]);
      solvedEntity = viewer.entities.add({
        polyline: {
          positions: Cesium.Cartesian3.fromRadiansArray(rad),
          width: 3,
          material: new Cesium.PolylineGlowMaterialProperty({ glowPower: 0.15, color: Cesium.Color.RED }),
          clampToGround: true
        }
      });
      const rect = Cesium.Rectangle.fromRadians(
        Math.min(...points.map(p=>Cesium.Math.toRadians(p.lon))),
        Math.min(...points.map(p=>Cesium.Math.toRadians(p.lat))),
        Math.max(...points.map(p=>Cesium.Math.toRadians(p.lon))),
        Math.max(...points.map(p=>Cesium.Math.toRadians(p.lat)))
      );
      viewer.camera.flyTo({ destination: rect, duration: 0.8 });
    }
    

    // ---------- Solve with local Flask A* ----------
    $("gridVal").textContent = grid.value;
    $("marginVal").textContent = margin.value;
    $("maxSlopeVal").textContent = (+maxSlope.value).toFixed(2);
    $("slopeWVal").textContent = (+slopeW.value).toFixed(2);

    $("solve").onclick = async () => {
      if (waypoints.length < 2) { status("Add at least Start and End."); return; }
      status("Solving (local Flask A*)…");
      try {
        const res = await solveRouteViaAPI(
          waypoints, +grid.value, +margin.value, +maxSlope.value, +slopeW.value
        );
        drawSolvedRoute(res.positions);
        status(`A* total cost ≈ ${(res.total_cost_m/1000).toFixed(2)} km`);
      } catch (e) {
        console.error(e);
        status("⚠ " + e.message);
      }
    };
  </script>
</body>
</html>
