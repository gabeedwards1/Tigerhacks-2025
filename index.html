<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Mars Viewer</title>
        <script src="https://cesium.com/downloads/cesiumjs/releases/1.123/Build/Cesium/Cesium.js"></script>
        <link href="https://cesium.com/downloads/cesiumjs/releases/1.123/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
        <style>
      html,
      body,
      #cesiumContainer {
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
        overflow: hidden;
        display: block;
      }
        </style>
    </head>
    <body>
        <div id="cesiumContainer"></div>
        <script src="config.js"></script>
        <script>
                const { TITILER_URL, FLASK_URL, MARS_TIF } = window.__ENV__;
                const tileUrl = `${TITILER_URL}/cog/tiles/WorldCRS84Quad/{z}/{x}/{y}@1x?url=${FLASK_URL}/${MARS_TIF}&colormap_name=inferno`;

                const viewer = new Cesium.Viewer("cesiumContainer", {
                  imageryProvider: false,
                  baseLayerPicker: false,
                  animation: false,
                  timeline: false,
                  creditContainer: document.createElement("div"),
                });

                viewer.scene.globe.ellipsoid = new Cesium.Ellipsoid(
                  3396190.0,
                  3396190.0,
                  3376200.0
                );

                viewer.scene.screenSpaceCameraController.minimumZoomDistance = 4.0e5;
                viewer.scene.screenSpaceCameraController.maximumZoomDistance = 3.0e7;

                viewer.imageryLayers.addImageryProvider(
                  new Cesium.UrlTemplateImageryProvider({
                    url: tileUrl,
                    tilingScheme: new Cesium.GeographicTilingScheme(),
                    rectangle: Cesium.Rectangle.fromDegrees(-180, -90, 180, 90),
                    credit: "Mars 6.25° data via TiTiler + Flask",
                  })
                );

                viewer.scene.fog.enabled = false;
                viewer.scene.globe.showGroundAtmosphere = false;
                if (viewer.scene.skyAtmosphere) viewer.scene.skyAtmosphere.show = false;

                const imageryLayer = viewer.imageryLayers.get(0);
                imageryLayer.alpha = 0.9;
                imageryLayer.brightness = 1.1;
                imageryLayer.saturation = 0.4;

                viewer.camera.flyTo({
                  destination: Cesium.Cartesian3.fromDegrees(-133.3, 18.4, 3_500_000),
                });

                const scene = viewer.scene;
                const camera = scene.camera;

                function isVisibleToCamera(cartesian) {
                  const occluder = new Cesium.EllipsoidalOccluder(
                    scene.globe.ellipsoid,
                    camera.positionWC
                  );
                  return occluder.isPointVisible(cartesian);
                }

                scene.postRender.addEventListener(() => {
                  viewer.entities.values.forEach((entity) => {
                    if (!entity.position || !entity.label) return;
                    const pos = Cesium.Property.getValueOrDefault(
                      entity.position,
                      scene.time
                    );
                    const visible = isVisibleToCamera(pos);
                    entity.label.show = visible;
                    if (entity.billboard) entity.billboard.show = visible;
                  });
                });
          
          const marsEllipsoid = viewer.scene.globe.ellipsoid;

 function normalizeLon(lonDeg) {
  return ((lonDeg + 180) % 360) - 180;
}

fetch("./mars_landmarks.geojson")
  .then(r => r.json())
  .then(geojson => {
    const features = geojson.features ?? [];
    features.forEach(f => {
      const [lonRaw, lat] = f.geometry.coordinates;
      const lon = normalizeLon(lonRaw);
      const pos = viewer.scene.globe.ellipsoid.cartographicToCartesian(
        Cesium.Cartographic.fromDegrees(lon, lat, 0.0)
      );
      viewer.entities.add({
        name: f.properties?.name ?? "Unnamed",
        position: pos,
        point: { pixelSize: 6, color: Cesium.Color.fromCssColorString("#c34a2c") },
        label: {
          text: f.properties?.name ?? "",
          font: "20px 'Segoe UI Semibold', sans-serif",
          fillColor: Cesium.Color.fromCssColorString("#f8debd"),
          outlineColor: Cesium.Color.BLACK.withAlpha(0.7),
          outlineWidth: 3,
          style: Cesium.LabelStyle.FILL_AND_OUTLINE,
          verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
          pixelOffset: new Cesium.Cartesian2(0, -18),
          disableDepthTestDistance: 0
        }
      });
    });
  })
            .catch((err) => console.error("GeoJSON load failed:", err));

          const handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
          const coordLabel = document.createElement("div");
          coordLabel.style.position = "absolute";
          coordLabel.style.bottom = "10px";
          coordLabel.style.left = "10px";
          coordLabel.style.padding = "4px 8px";
          coordLabel.style.background = "rgba(0,0,0,0.6)";
          coordLabel.style.color = "white";
          coordLabel.style.fontFamily = "monospace";
          coordLabel.style.fontSize = "13px";
          coordLabel.style.borderRadius = "4px";
          document.body.appendChild(coordLabel);

          handler.setInputAction((movement) => {
            const ray = viewer.camera.getPickRay(movement.endPosition);
            const cartesian = viewer.scene.globe.pick(ray, viewer.scene);

            if (cartesian) {
              const marsEllipsoid = viewer.scene.globe.ellipsoid;
              const carto = marsEllipsoid.cartesianToCartographic(cartesian);
              const lat = Cesium.Math.toDegrees(carto.latitude).toFixed(5);
              const lon = Cesium.Math.toDegrees(carto.longitude).toFixed(5);
              coordLabel.textContent = `Lon: ${lon}°, Lat: ${lat}°`;
            } else {
              coordLabel.textContent = "Off planet";
            }
          }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

           // Auto-rotation and zoom out after idle time
    let idleTimeout;
    let isRotating = false;
    let hasZoomedOut = false;
    const IDLE_TIME = 3000; // 3 seconds of idle time before zoom and rotation starts
    const ROTATION_SPEED = 0.001; // Rotation speed

    function startRotation() {
      if (!isRotating) {
        isRotating = true;
        
        // Zoom out if we haven't already
        if (!hasZoomedOut) {
          hasZoomedOut = true;
          viewer.camera.flyTo({
            destination: Cesium.Cartesian3.fromDegrees(-133.3, 18.4, 15_000_000),
            duration: 3, // 3 seconds to zoom out
          });
        }
        
        viewer.clock.onTick.addEventListener(rotateCamera);
      }
    }

    function stopRotation() {
      if (isRotating) {
        isRotating = false;
        hasZoomedOut = false;
        viewer.clock.onTick.removeEventListener(rotateCamera);
      }
    }

    function rotateCamera() {
      const camera = viewer.camera;
      camera.rotate(Cesium.Cartesian3.UNIT_Z, ROTATION_SPEED);
    }

    function resetIdleTimer() {
      stopRotation();
      clearTimeout(idleTimeout);
      idleTimeout = setTimeout(startRotation, IDLE_TIME);
    }

    // Stop rotation and reset timer on any user interaction
    viewer.scene.canvas.addEventListener('mousedown', resetIdleTimer);
    viewer.scene.canvas.addEventListener('wheel', resetIdleTimer);
    viewer.scene.canvas.addEventListener('touchstart', resetIdleTimer);

    // Start the initial idle timer
    resetIdleTimer();
        </script>
    </body>
</html>
