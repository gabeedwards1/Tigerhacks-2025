<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Mars Viewer — A* Route Planner</title>

  <!-- CesiumJS -->
  <script src="https://cesium.com/downloads/cesiumjs/releases/1.123/Build/Cesium/Cesium.js"></script>
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.123/Build/Cesium/Widgets/widgets.css" rel="stylesheet">

  <style>
    html, body, #cesiumContainer {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
      display: block;
    }

    /* Waypoint control panel (from your other file) */
    #panel {
      position: absolute; top: 12px; left: 12px; z-index: 1000;
      width: 360px; padding: 12px 14px;
      background: #121726; color: #e8ecff; border: 2px solid #2a3357; border-radius: 14px;
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
    }
    #panel h1 { margin: 0 0 8px 0; font-size: 16px; }
    #panel .row { display: flex; gap: 8px; align-items: center; margin: 8px 0; flex-wrap: wrap; }
    #panel button {
      background: #7aa2ff; border: none; color: #0c0f17; font-weight: 600;
      padding: 8px 10px; border-radius: 10px; cursor: pointer;
    }
    #panel button.secondary { background: #222a4a; color: #e6ecff; border: 1px solid #2f396b; }
    #panel label { font-size: 12px; color: #b9c0d9; }
    #panel input[type="range"] { width: 150px; }
    #panel .pill { display: inline-block; padding: 2px 8px; border-radius: 999px; background: #1c2340; border: 1px solid #2b3663; font-size: 11px; color: #cdd7ff; }
    #panel #status { font-size: 12px; color: #9fb2ff; min-height: 1.4em; margin-top: 6px; }
    #panel #list { max-height: 130px; overflow: auto; border-top: 1px dashed #2b3663; padding-top: 6px; font-size: 12px; }

    /* Small legend bubble (optional) */
    #legend {
      position: absolute; bottom: 14px; left: 12px; z-index: 1000;
      background: #121726; color: #cdd7ff; border: 1px solid #2b3663;
      padding: 6px 8px; border-radius: 10px; font-size: 12px;
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }

    /* Mouse coordinate label */
    #coordLabel {
      position: absolute; bottom: 10px; left: 10px; padding: 4px 8px;
      background: rgba(0,0,0,0.6); color: white; font-family: monospace;
      font-size: 13px; border-radius: 4px; z-index: 1000;
    }
  </style>
</head>
<body>
  <div id="cesiumContainer"></div>

  <!-- Waypoint UI panel -->
  <div id="panel">
    <h1>Mars Waypoints <span class="pill">A*</span></h1>

    <div class="row">
      <button id="toggleAdd">Adding… (click globe)</button>
      <button id="undo" class="secondary">Undo</button>
      <button id="clear" class="secondary">Clear</button>
    </div>

    <div class="row">
      <label>Grid (N × N)</label>
      <input id="grid" type="range" min="64" max="256" step="32" value="128">
      <span id="gridVal" class="pill">128</span>
    </div>
    <div class="row">
      <label>BBox margin (km)</label>
      <input id="margin" type="range" min="5" max="200" step="5" value="40">
      <span id="marginVal" class="pill">40</span>
    </div>
    <div class="row">
      <label>Max slope (grade)</label>
      <input id="maxSlope" type="range" min="0.05" max="1.5" step="0.05" value="0.60">
      <span id="maxSlopeVal" class="pill">0.60</span>
    </div>
    <div class="row">
      <label>Slope weight</label>
      <input id="slopeW" type="range" min="0" max="8" step="0.25" value="2.0">
      <span id="slopeWVal" class="pill">2.00</span>
    </div>

    <div class="row">
      <button id="solve">Solve Route (A*)</button>
      <button id="download" class="secondary">Download JSON</button>
    </div>

    <div id="status"></div>
    <div id="list"><em>No waypoints yet.</em></div>
  </div>

  <div id="legend">Toggle “Adding…”, then click the globe: Start → WP1 → … → End. Press “Solve Route (A*)”.</div>
  <div id="coordLabel">Lon: —, Lat: —</div>

  <!-- Your environment values (TITILER_URL / FLASK_URL / MARS_TIF) -->
  <script src="config.js"></script>
  <script>
    // ---------- ENV ----------
    const { TITILER_URL, FLASK_URL, MARS_TIF } = window.__ENV__ || {};
    const tileUrl = `${TITILER_URL}/cog/tiles/WorldCRS84Quad/{z}/{x}/{y}@1x?url=${FLASK_URL}/${MARS_TIF}&colormap_name=inferno`;

    // ---------- Cesium viewer ----------
    const viewer = new Cesium.Viewer("cesiumContainer", {
      imageryProvider: false,
      baseLayerPicker: false,
      animation: false,
      timeline: false,
      creditContainer: document.createElement("div"),
      sceneModePicker: true,
      selectionIndicator: false,
      scene3DOnly: true
    });

    // Mars ellipsoid
    viewer.scene.globe.ellipsoid = new Cesium.Ellipsoid(3396190.0, 3396190.0, 3376200.0);
    // Camera limits
    viewer.scene.screenSpaceCameraController.minimumZoomDistance = 4.0e5;
    viewer.scene.screenSpaceCameraController.maximumZoomDistance = 3.0e7;

    // Raster imagery
    viewer.imageryLayers.addImageryProvider(
      new Cesium.UrlTemplateImageryProvider({
        url: tileUrl,
        tilingScheme: new Cesium.GeographicTilingScheme(),
        rectangle: Cesium.Rectangle.fromDegrees(-180, -90, 180, 90),
        credit: "Mars 6.25° data via TiTiler + Flask",
      })
    );

    viewer.scene.fog.enabled = false;
    viewer.scene.globe.showGroundAtmosphere = false;
    if (viewer.scene.skyAtmosphere) viewer.scene.skyAtmosphere.show = false;

    const imageryLayer = viewer.imageryLayers.get(0);
    imageryLayer.alpha = 0.9;
    imageryLayer.brightness = 1.1;
    imageryLayer.saturation = 0.4;

    viewer.camera.flyTo({
      destination: Cesium.Cartesian3.fromDegrees(-133.3, 18.4, 3_500_000),
    });

    // ---------- Landmark pins (kept from your file) ----------
    function normalizeLon(lonDeg) { return ((lonDeg + 180) % 360) - 180; }

    fetch("./mars_landmarks.geojson")
      .then(r => r.json())
      .then(geojson => {
        const features = geojson.features ?? [];
        features.forEach(f => {
          const [lonRaw, lat] = f.geometry.coordinates;
          const lon = normalizeLon(lonRaw);
          const pos = viewer.scene.globe.ellipsoid.cartographicToCartesian(
            Cesium.Cartographic.fromDegrees(lon, lat, 0.0)
          );
          viewer.entities.add({
            name: f.properties?.name ?? "Unnamed",
            position: pos,
            point: { pixelSize: 6, color: Cesium.Color.fromCssColorString("#c34a2c") },
            label: {
              text: f.properties?.name ?? "",
              font: "20px 'Segoe UI Semibold', sans-serif",
              fillColor: Cesium.Color.fromCssColorString("#f8debd"),
              outlineColor: Cesium.Color.BLACK.withAlpha(0.7),
              outlineWidth: 3,
              style: Cesium.LabelStyle.FILL_AND_OUTLINE,
              verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
              pixelOffset: new Cesium.Cartesian2(0, -18),
              disableDepthTestDistance: 0
            }
          });
        });
      })
      .catch((err) => console.error("GeoJSON load failed:", err));

    // ---------- Visibility for labels on the far side (kept) ----------
    const scene = viewer.scene;
    const camera = scene.camera;
    function isVisibleToCamera(cartesian) {
      const occluder = new Cesium.EllipsoidalOccluder(scene.globe.ellipsoid, camera.positionWC);
      return occluder.isPointVisible(cartesian);
    }
    scene.postRender.addEventListener(() => {
      viewer.entities.values.forEach((entity) => {
        if (!entity.position || !entity.label) return;
        const pos = Cesium.Property.getValueOrDefault(entity.position, scene.time);
        const visible = isVisibleToCamera(pos);
        entity.label.show = visible;
        if (entity.billboard) entity.billboard.show = visible;
      });
    });

    // ---------- Mouse coordinate readout (kept) ----------
    const coordLabel = document.getElementById("coordLabel");
    const handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
    handler.setInputAction((movement) => {
      const ray = viewer.camera.getPickRay(movement.endPosition);
      const cartesian = viewer.scene.globe.pick(ray, viewer.scene);
      if (cartesian) {
        const carto = viewer.scene.globe.ellipsoid.cartesianToCartographic(cartesian);
        const lat = Cesium.Math.toDegrees(carto.latitude).toFixed(5);
        const lon = Cesium.Math.toDegrees(carto.longitude).toFixed(5);
        coordLabel.textContent = `Lon: ${lon}°, Lat: ${lat}°`;
      } else {
        coordLabel.textContent = "Off planet";
      }
    }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

    // ---------- Idle auto-rotation (kept) ----------
    let idleTimeout, isRotating = false, hasZoomedOut = false;
    const IDLE_TIME = 3000; // ms
    const ROTATION_SPEED = 0.001;
    function rotateCamera() { viewer.camera.rotate(Cesium.Cartesian3.UNIT_Z, ROTATION_SPEED); }
    function startRotation() {
      if (!isRotating) {
        isRotating = true;
        if (!hasZoomedOut) {
          hasZoomedOut = true;
          viewer.camera.flyTo({
            destination: Cesium.Cartesian3.fromDegrees(-133.3, 18.4, 15_000_000),
            duration: 3,
          });
        }
        viewer.clock.onTick.addEventListener(rotateCamera);
      }
    }
    function stopRotation() {
      if (isRotating) {
        isRotating = false; hasZoomedOut = false;
        viewer.clock.onTick.removeEventListener(rotateCamera);
      }
    }
    function resetIdleTimer() {
      stopRotation();
      clearTimeout(idleTimeout);
      idleTimeout = setTimeout(startRotation, IDLE_TIME);
    }
    viewer.scene.canvas.addEventListener('mousedown', resetIdleTimer);
    viewer.scene.canvas.addEventListener('wheel', resetIdleTimer);
    viewer.scene.canvas.addEventListener('touchstart', resetIdleTimer);
    resetIdleTimer();

    // ---------- Waypoint + A* (added) ----------
    const $ = id => document.getElementById(id);
    const btnAdd = $("toggleAdd");
    const btnUndo = $("undo");
    const btnClear = $("clear");
    const btnSolve = $("solve");
    const btnDownload = $("download");
    const grid = $("grid"), gridVal = $("gridVal");
    const margin = $("margin"), marginVal = $("marginVal");
    const maxSlope = $("maxSlope"), maxSlopeVal = $("maxSlopeVal");
    const slopeW = $("slopeW"), slopeWVal = $("slopeWVal");
    const statusEl = $("status"), listEl = $("list");

    grid.oninput = () => gridVal.textContent = grid.value;
    margin.oninput = () => marginVal.textContent = margin.value;
    maxSlope.oninput = () => maxSlopeVal.textContent = (+maxSlope.value).toFixed(2);
    slopeW.oninput = () => slopeWVal.textContent = (+slopeW.value).toFixed(2);
    function status(msg){ statusEl.textContent = msg || ""; }

    const waypoints = []; // {lon, lat, entity}
    let adding = true;
    let dashedEntity = null;
    let solvedEntity = null;

    btnAdd.onclick = () => {
      adding = !adding;
      btnAdd.textContent = adding ? "Adding… (click globe)" : "Add Waypoints";
      btnAdd.classList.toggle("secondary", !adding);
      status(adding ? "Click the globe to add waypoints." : "");
    };

    btnUndo.onclick = () => {
      const last = waypoints.pop();
      if (last?.entity) viewer.entities.remove(last.entity);
      redrawDashed(); renderList(); status("Undid last waypoint.");
    };

    btnClear.onclick = () => {
      waypoints.splice(0, waypoints.length);
      if (dashedEntity) { viewer.entities.remove(dashedEntity); dashedEntity = null; }
      if (solvedEntity) { viewer.entities.remove(solvedEntity); solvedEntity = null; }
      viewer.entities.values
        .filter(e => e.__isWP)
        .forEach(e => viewer.entities.remove(e));
      renderList(); status("Cleared.");
    };

    btnDownload.onclick = () => {
      if (!waypoints.length) return;
      const data = { positions: waypoints.map(p => ({ lon: p.lon, lat: p.lat })) };
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = "route_lonlat.json";
      a.click();
      URL.revokeObjectURL(a.href);
    };

    function renderList(){
      if (!waypoints.length){ listEl.innerHTML = "<em>No waypoints yet.</em>"; return; }
      listEl.innerHTML = waypoints.map((p,i) => {
        const tag = i===0 ? "Start" : (i===waypoints.length-1 ? "End" : `WP${i}`);
        return `<div>${i+1}. <b>${tag}</b> — lon ${p.lon.toFixed(4)}, lat ${p.lat.toFixed(4)}</div>`;
      }).join("");
    }

    function redrawDashed(){
      if (dashedEntity){ viewer.entities.remove(dashedEntity); dashedEntity = null; }
      if (waypoints.length < 2) return;
      const degs = waypoints.flatMap(p => [p.lon, p.lat]);
      dashedEntity = viewer.entities.add({
        polyline: {
          positions: Cesium.Cartesian3.fromDegreesArray(degs),
          width: 2,
          material: new Cesium.PolylineDashMaterialProperty({ color: Cesium.Color.RED, dashLength: 12 }),
          clampToGround: false
        }
      });
      try {
        const rect = Cesium.Rectangle.fromDegrees(
          Math.min(...waypoints.map(p=>p.lon)), Math.min(...waypoints.map(p=>p.lat)),
          Math.max(...waypoints.map(p=>p.lon)), Math.max(...waypoints.map(p=>p.lat))
        );
        viewer.camera.flyTo({ destination: rect, duration: 0.6 });
      } catch(_) {}
    }

    function addWaypoint(lon, lat){
      const label = waypoints.length===0 ? "START" :
                    (waypoints.length===1 ? "END?" : `WP${waypoints.length}`);
      const entity = viewer.entities.add({
        __isWP: true,
        position: Cesium.Cartesian3.fromDegrees(lon, lat),
        point: { pixelSize: 8, color: Cesium.Color.CYAN, outlineColor: Cesium.Color.WHITE, outlineWidth: 1 },
        label: {
          text: `${label}\n${lon.toFixed(4)}, ${lat.toFixed(4)}`,
          font: "bold 14px sans-serif",
          showBackground: true,
          backgroundColor: Cesium.Color.fromBytes(18,23,38,220),
          pixelOffset: new Cesium.Cartesian2(0, -18),
          disableDepthTestDistance: Number.POSITIVE_INFINITY
        }
      });
      waypoints.push({ lon, lat, entity });
      renderList();
      redrawDashed();
    }

    // Reuse existing handler; add LEFT_CLICK for waypoint placement
    handler.setInputAction((movement) => {
      if (!adding) return;
      const ellipsoid = viewer.scene.globe.ellipsoid;
      const cart = viewer.camera.pickEllipsoid(movement.position, ellipsoid) || viewer.scene.pickPosition(movement.position);
      if (!cart) return;
      const carto = Cesium.Cartographic.fromCartesian(cart, ellipsoid);
      const lon = Cesium.Math.toDegrees(carto.longitude);
      const lat = Cesium.Math.toDegrees(carto.latitude);
      addWaypoint(lon, lat);
      resetIdleTimer(); // any interaction cancels idle rotation
    }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

    function drawSolvedRoute(points){
      if (solvedEntity) { viewer.entities.remove(solvedEntity); solvedEntity = null; }
      const rad = points.flatMap(p => [Cesium.Math.toRadians(p.lon), Cesium.Math.toRadians(p.lat)]);
      solvedEntity = viewer.entities.add({
        polyline: {
          positions: Cesium.Cartesian3.fromRadiansArray(rad),
          width: 3,
          material: new Cesium.PolylineGlowMaterialProperty({ glowPower: 0.15, color: Cesium.Color.RED }),
          clampToGround: true
        }
      });
      const rect = Cesium.Rectangle.fromRadians(
        Math.min(...points.map(p=>Cesium.Math.toRadians(p.lon))),
        Math.min(...points.map(p=>Cesium.Math.toRadians(p.lat))),
        Math.max(...points.map(p=>Cesium.Math.toRadians(p.lon))),
        Math.max(...points.map(p=>Cesium.Math.toRadians(p.lat)))
      );
      viewer.camera.flyTo({ destination: rect, duration: 0.8 });
    }

    // Local A* API (server-side): POST /astar/solve
    async function solveRouteViaAPI(waypoints, gridN, marginKm, maxSlope, slopeW) {
      const payload = {
        positions: waypoints.map(p => ({ lon: p.lon, lat: p.lat })),
        grid: gridN,
        margin_km: marginKm,
        max_slope: maxSlope,
        slope_weight: slopeW
      };
      const resp = await fetch(`${FLASK_URL}/astar/solve`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });
      const js = await resp.json();
      if (!resp.ok || js.error) throw new Error(js.error || "A* failed");
      return js; // { positions: [...], total_cost_m, legs_m }
    }

    // Initialize slider pills
    gridVal.textContent = grid.value;
    marginVal.textContent = margin.value;
    maxSlopeVal.textContent = (+maxSlope.value).toFixed(2);
    slopeWVal.textContent = (+slopeW.value).toFixed(2);

    // Solve button
    $("solve").onclick = async () => {
      if (waypoints.length < 2) { status("Add at least Start and End."); return; }
      status("Solving (local Flask A*)…");
      try {
        const res = await solveRouteViaAPI(
          waypoints, +grid.value, +margin.value, +maxSlope.value, +slopeW.value
        );
        drawSolvedRoute(res.positions);
        // Show distance-like cost if present
        if (typeof res.total_cost_m === "number") {
          status(`A* total cost ≈ ${(res.total_cost_m/1000).toFixed(2)} km`);
        } else if (typeof res.total_energy_kWh === "number") {
          status(`A* total energy ≈ ${res.total_energy_kWh.toFixed(3)} kWh`);
        } else {
          status("A* solved.");
        }
        resetIdleTimer();
      } catch (e) {
        console.error(e);
        status("⚠ " + e.message);
      }
    };
  </script>
</body>
</html>
